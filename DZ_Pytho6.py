# 1. Представлен список чисел. Необходимо вывести элементы исходного 
# списка, значения которых больше предыдущего элемента. Use comprehension.
# in
# 9
# out
# [15, 16, 2, 3, 1, 7, 5, 4, 10]
# [16, 3, 7, 10]
# in
# 10
# out
# [28, 20, 10, 5, 1, 24, 7, 15, 23, 25]
# [24, 15, 23, 25]

# from random import randint, random

# num = int(input('Введите количество элементов: '))
# list = [randint(1, 20) for i in range(num)]  
# print(list)
# res = [list[i] for i in range(1, len(list)) if list[i] > list[i-1]]
# print(res) 


# 2. Для чисел в пределах от 20 до N найти числа, кратные
#  20 или 21. Use comprehension.
# in
# 100

# out
# [20, 21, 40, 42, 60, 63, 80, 84, 100]

# in
# 424

# out
# [20, 21, 40, 42, 60, 63, 80, 84, 100, 105, 120, 126, 
# 140, 147, 160, 168, 180, 189, 200, 210, 220, 231, 240,
#  252, 260, 273, 280, 294, 300, 315, 320, 336, 340, 357,
#   360, 378, 380, 399, 400, 420]

# num = int(input('Введите число: '))
# multiples = [i for i in range(20, num) if i % 20 == 0 or i % 21 == 0]
# print(multiples)

# 3. Написать функцию, аргументы имена сотрудников, возвращает 
# словарь, ключи — первые буквы имён, значения — списки, содержащие 
# имена, начинающиеся с соответствующей буквы.
# in
# "Иван", "Мария", "Петр", "Илья", "Марина", "Петр", "Алина", "Бибочка"

# out

# {'А': ['Алина'], 'Б': ['Бибочка'], 'И': ['Иван', 'Илья'],
#  'М': ['Марина', 'Мария'], 'П': ['Петр', 'Петр']}


# Вариант I(Показывает только количество слов на букву ключ)

# lst = ["Иван", "Мария", "Петр", "Илья", "Марина", "Петр", "Алина", "Бибочка"]
# def corrections(lst: list) -> dict:
#     dic = {}
#     for string in lst:
#         for word in string.split():
#             dic[word[0]] = dic.setdefault(word[0], 0) + 1
#     return dic
# print(corrections(lst))

# Вариант II   

# from itertools import groupby
# def corrections(*args):
#     if "" not in args:
#         return {ch: list(names) for ch, names in groupby(sorted(args), key=lambda i: i[0]) if ch}
# print(corrections("Иван", "Мария", "Петр", "Илья", "Марина", "Петр", "Алина", "Бибочка")) 

# Вариант III (2 и 3 срисовал с семинара(если честно))

# def sortrd_dict(*words):
#     dict = {}
#     for i in sorted(words):
#         sign = i[0]
#         if sign not in dict:
#             dict[sign] = [i]
#             dict[sign] += [i]
#     return dict  
# print(sortrd_dict("Иван", "Мария", "Петр", "Илья", "Марина", "Петр", "Алина", "Бибочка"))          
        
# 4. * Функция принимает в качестве аргументов строки в
#  формате «Имя Фамилия», возвращает словарь, ключи — первые
#   буквы фамилий, значения — словари, реализованные по схеме предыдущего задания.
# in
# "Иван Сергеев", "Инна Серова", "Петр Алексеев",
# "Илья Иванов", "Анна Савельева", "Юнона Ветрякова",
# "Борис Аркадьев", "Антон Серов", "Павел Анисимов"

# out

# {'С': {'А': ['Анна Савельева', 'Антон Серов'],
#  'И': ['Иван Сергеев', 'Инна Серова']},
#   'А': {'Б': ['Борис Аркадьев'], 'П': ['Павел Анисимов', 'Петр Алексеев']}, 
#   'И': {'И': ['Илья Иванов']}, 'В': {'Ю': ['Юнона Ветрякова']}}

# 5. ** Реализовать функцию, возвращающую n шуток, сформированных
#  из трех случайных слов, взятых из трёх списков (по одному из каждого)
# nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
# adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью", "когда-то", "где-то"]
# adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]

# in
# 10 True

# out

# ['дом ночью мягкий', 'огонь завтра зеленый', 'лес вчера яркий',
#  'автомобиль сегодня веселый', 'город позавчера утопичный']

# in
# 10 False

# ['автомобиль ночью мягкий', 'огонь вчера веселый', 
# 'автомобиль позавчера веселый', 'город вчера утопичный', 
# 'лес сегодня зеленый', 'дом вчера яркий', 'автомобиль вчера зеленый',
#  'огонь позавчера яркий', 'огонь где-то утопичный', 'автомобиль где-то мягкий']